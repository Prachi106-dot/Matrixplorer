<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orthogonal Trajectories Explorer</title>
  <script src="https://cdn.jsdelivr.net/npm/mathjs@11.12.0/lib/browser/math.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#4f46e5;--muted:#94a3b8;color-scheme:dark}
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
    body{margin:0;background:linear-gradient(180deg,#071024 0%, #07172a 100%);color:#e6eef8}
    header{display:flex;align-items:center;justify-content:space-between;padding:18px 24px}
    .brand{display:flex;gap:12px;align-items:center}
    .logo{width:46px;height:46px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#06b6d4);display:flex;align-items:center;justify-content:center;font-weight:700}
    nav a{color:var(--muted);margin-left:18px;text-decoration:none}
    .container{max-width:1100px;margin:18px auto;padding:18px}
    .card{background:rgba(255,255,255,0.03);border-radius:12px;padding:18px;margin-bottom:18px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    .grid{display:grid;grid-template-columns:1fr 420px;gap:16px}
    label{display:block;margin-bottom:6px;color:var(--muted)}
    input[type=text],textarea,select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{background:var(--accent);border:none;padding:10px 12px;border-radius:8px;color:white;cursor:pointer}
    small{color:var(--muted)}
    footer{padding:14px;text-align:center;color:var(--muted)}
    .steps pre{background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;overflow:auto}
    .help-links a{display:inline-block;margin-right:12px;color:var(--muted)}
    /* responsive */
    @media(max-width:980px){.grid{grid-template-columns:1fr}nav{display:none}}
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo">OT</div>
      <div>
        <div style="font-weight:700;font-size:16px">Orthogonal Trajectories Explorer</div>
        <div style="font-size:12px;color:var(--muted)">Interactive visual solver and plotter (in-browser)</div>
      </div>
    </div>
    <nav>
      <a href="#/">Home</a>
      <a href="#/solver">Solver</a>
      <a href="#/review">Review</a>
      <a href="#/help">Help</a>
      <a href="#/contact">Contact</a>
    </nav>
  </header>  <main class="container">
    <!-- Pages handled by simple hash router -->
    <div id="page-root"></div>
  </main>  <footer class="container"><div class="card" style="text-align:center">Built for learning — enter families of curves of the form <code>expr(x,y) = C</code> (see Help). This runs fully inside your browser — no server required.</div></footer>  <script>
  // Simple SPA router
  const root = document.getElementById('page-root');
  function route(){
    const hash = location.hash.replace('#','') || '/';
    if(hash.startsWith('/solver')) renderSolver();
    else if(hash.startsWith('/review')) renderReview();
    else if(hash.startsWith('/help')) renderHelp();
    else if(hash.startsWith('/contact')) renderContact();
    else renderHome();
  }
  window.addEventListener('hashchange', route);
  route();

  // Utility: escape HTML
  function esc(s){return (s+'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}

  function renderHome(){
    root.innerHTML = `
      <div class="card">
        <h2>What are Orthogonal Trajectories?</h2>
        <p>Orthogonal trajectories are curves that intersect every member of a given family of curves at right angles. Given a family described by <code>F(x,y)=C</code>, the usual steps are:</p>
        <ol>
          <li>Differentiate implicitly to find <code>dy/dx</code> for the given family.</li>
          <li>Replace <code>dy/dx</code> by the negative reciprocal (i.e. slope m -> -1/m) to get the slope of the orthogonal trajectories.</li>
          <li>Solve the resulting differential equation to obtain the orthogonal family.</li>
        </ol>
        <p>Use the <a href="#/solver">Solver</a> to enter a family of curves (format: <code>expr(x,y) = C</code>) and see step-by-step work and plots.</p>
      </div>

      <div class="grid">
        <div class="card">
          <h3>Quick example</h3>
          <p>Enter <code>x^2 + y^2 = C</code> on the Solver page, click <strong>Compute</strong>, and the page will show the differentiation steps, the orthogonal ODE and plot both families.</p>
          <div class="steps">
            <h4>What the app will do</h4>
            <pre>1) Compute partial derivatives F_x, F_y
2) dy/dx (given) = -F_x / F_y
3) Orthogonal slope: (dy/dx)_orth = F_y / F_x
4) Numerically integrate (dy/dx)_orth = F_y/F_x to draw trajectories
5) Plot original family level sets as contours at several C values
</pre></div>
    </div>

    <div class="card">
      <h3>Quick links</h3>
      <div class="help-links">
        <a href="#/solver">Open Solver</a>
        <a href="#/help">How to use</a>
        <a href="#/contact">Contact</a>
      </div>
    </div>
  </div>
`;

}

function renderHelp(){ root.innerHTML = <div class="card"> <h2>Help — how to format input</h2> <p>To keep parsing and implicit differentiation reliable, enter the family in the exact form <code>expression = C</code>, where <code>expression</code> is a function of <code>x</code> and <code>y</code> (no other parameters) and the right-hand side is exactly the single capital letter <code>C</code>. Examples:</p> <ul> <li><code>x^2 + y^2 = C</code></li> <li><code>y^2 = C*x</code></li> <li><code>y = C*e^(-x)</code> (allowed — RHS must be just C times something? Actually keep RHS exactly 'C' — see note)</li> </ul> <p><strong>Important:</strong> For correct symbolic steps this demo expects the RHS to be <code>C</code> only (so your family should be of the form <code>F(x,y)=C</code>). If your family is written differently, rewrite it algebraically so the constant stands alone on the right.</p> <h3>Supported functions</h3> <p>Standard math.js expressions are supported: <code>sin, cos, tan, exp, log, sqrt, ^</code>, etc. Use <code>y</code> and <code>x</code> as your variables.</p> </div>; }

function renderContact(){ root.innerHTML = <div class="card"> <h2>Contact & Help</h2> <p>If you found a bug or want a feature, tell us here. This is a static demo so contact will simply record your message locally (for privacy it does not go to any server).</p> <label for="name">Your name</label> <input id="name" type="text" placeholder="Optional" /> <label for="msg">Message</label> <textarea id="msg" rows="6" placeholder="Describe an issue or request"></textarea> <div style="margin-top:8px"><button id="sendBtn">Save message locally</button></div> <div id="sendResult" style="margin-top:8px;color:var(--muted)"></div> </div>; document.getElementById('sendBtn').addEventListener('click', ()=>{ const name = document.getElementById('name').value||'Anonymous'; const msg = document.getElementById('msg').value||''; if(!msg.trim()){document.getElementById('sendResult').innerText='Please enter a message.';return} const store = JSON.parse(localStorage.getItem('ot_messages')||'[]'); store.push({name, msg, at:new Date().toISOString()}); localStorage.setItem('ot_messages', JSON.stringify(store)); document.getElementById('sendResult').innerText='Saved locally — thanks! (This demo does not send messages externally)'; document.getElementById('msg').value=''; }); }

function renderReview(){ root.innerHTML = <div class="card"> <h2>Review this demo</h2> <p>Share feedback (saved locally in your browser).</p> <label for="rating">Rating</label> <select id="rating"><option>5</option><option>4</option><option>3</option><option>2</option><option>1</option></select> <label for="review">Write a short review</label> <textarea id="review" rows=5></textarea> <div style="margin-top:8px"><button id="saveReview">Save review</button></div> <div id="revOut" style="margin-top:8px;color:var(--muted)"></div> <hr /> <h3>Saved reviews (local)</h3> <div id="listReviews"></div> </div>; document.getElementById('saveReview').addEventListener('click', ()=>{ const rating = document.getElementById('rating').value; const text = document.getElementById('review').value||''; if(!text.trim()){document.getElementById('revOut').innerText='Please enter a review.';return} const all = JSON.parse(localStorage.getItem('ot_reviews')||'[]'); all.push({rating,text,at:new Date().toISOString()}); localStorage.setItem('ot_reviews', JSON.stringify(all)); document.getElementById('revOut').innerText='Saved locally — thanks!'; document.getElementById('review').value=''; loadReviews(); }); loadReviews(); } function loadReviews(){ const list = JSON.parse(localStorage.getItem('ot_reviews')||'[]'); const container = document.getElementById('listReviews'); if(!container) return; if(!list.length) container.innerHTML='<small>No reviews yet.</small>'; else container.innerHTML = list.map(r=><div style="padding:8px;border-radius:8px;margin-bottom:8px;background:rgba(255,255,255,0.02)"><strong>Rating: ${esc(r.rating)}</strong><div style="font-size:13px;color:var(--muted)">${esc(r.text)}</div><div style="font-size:11px;color:var(--muted)">${esc(r.at)}</div></div>).join(''); }

// Solver page — main functionality function renderSolver(){ root.innerHTML = ` <div class="card"> <h2>Orthogonal Trajectories — Solver</h2> <p>Enter the family in the form <code>expression = C</code>. Example: <code>x^2 + y^2 = C</code>.</p> <label for="eqin">Family (F(x,y) = C)</label> <input id="eqin" type="text" value="x^2 + y^2 = C" /> <div style="margin-top:8px"><button id="compute">Compute</button></div> </div>

<div class="grid">
    <div class="card">
      <h3>Steps & Work</h3>
      <div id="stepsArea"><small>Press Compute to see symbolic steps.</small></div>
    </div>

    <div class="card">
      <h3>Plots</h3>
      <div id="plotArea" style="height:420px"></div>
      <div style="margin-top:8px"><small>Controls: grid range and number of sample trajectories.</small></div>
      <div style="margin-top:8px">
        <label>Range (±): <input id="range" type="text" value="5" style="width:80px;display:inline-block" /></label>
        <label style="margin-left:12px"># trajectories: <input id="ntra" type="number" value="8" min=1 max=40 style="width:80px;display:inline-block" /></label>
      </div>
    </div>
  </div>
`;

document.getElementById('compute').addEventListener('click', ()=>{
  computeFromInput();
});

}

// Core math & plotting functions function computeFromInput(){ const raw = document.getElementById('eqin').value.trim(); const stepsArea = document.getElementById('stepsArea'); const plotArea = document.getElementById('plotArea'); stepsArea.innerHTML = '<small>Working...</small>'; plotArea.innerHTML = '';

// Validate simple form: left = C
const parts = raw.split('=');
if(parts.length !== 2){stepsArea.innerHTML = '<div style="color:#ff9b9b">Input must contain exactly one = sign and be of the form <code>expression = C</code></div>';return}
const L = parts[0].trim();
const R = parts[1].trim();
if(R !== 'C'){stepsArea.innerHTML = '<div style="color:#ff9b9b">Right-hand side must be exactly the capital letter C (e.g. <code>x^2 + y^2 = C</code>).</div>';return}

try{
  // Use math.js to compute partial derivatives
  const expr = math.parse(L); // expression tree
  const FxNode = math.derivative(expr, 'x');
  const FyNode = math.derivative(expr, 'y');
  const FxStr = FxNode.toString();
  const FyStr = FyNode.toString();

  // Original family derivative by implicit differentiation: dy/dx = -Fx/Fy
  const origSlopeStr = `-(${FxStr})/(${FyStr})`;
  // Orthogonal slope: Fy/Fx
  const orthSlopeStr = `(${FyStr})/(${FxStr})`;

  // Show symbolic steps
  stepsArea.innerHTML = `<div><strong>Input family:</strong> <code>${esc(L)} = C</code></div>
    <div style="margin-top:8px"><strong>Step 1 — partial derivatives</strong>
    <div><code>F_x = ${esc(FxStr)}</code></div>
    <div><code>F_y = ${esc(FyStr)}</code></div></div>
    <div style="margin-top:8px"><strong>Step 2 — implicit differentiation</strong>
    <div>Since <code>F(x,y)=C</code> (constant), differentiate: <code>F_x + F_y * (dy/dx) = 0</code></div>
    <div>So <code>dy/dx = -F_x / F_y = ${esc(origSlopeStr)}</code></div></div>
    <div style="margin-top:8px"><strong>Step 3 — orthogonal slope</strong>
    <div>Orthogonal slopes satisfy <code>m_orth = -1/m</code>. Thus</div>
    <div><code>dy/dx (orth) = ${esc(orthSlopeStr)}</code></div></div>
    <div style="margin-top:8px;color:var(--muted)"><small>Now the app will numerically integrate the orthogonal ODE <code>dy/dx = ${esc(orthSlopeStr)}</code> for several initial points and draw level sets of <code>F(x,y)</code>.</small></div>`;

  // Prepare numeric functions
  const Fx = math.compile(FxStr);
  const Fy = math.compile(FyStr);
  const F = math.compile(L);

  // Numeric helpers
  function orthSlope(x,y){
    // Evaluate Fy/Fx (careful divide by zero)
    const scope = {x: x, y: y};
    const numFx = Fx.evaluate(scope);
    const numFy = Fy.evaluate(scope);
    if(Math.abs(numFx) < 1e-12) return null; // vertical slope -> skip
    return numFy/numFx;
  }

  // Integrate ODE dy/dx = orthSlope using RK4 for given initial point (x0,y0)
  function integrateRK4(x0,y0,h,steps,dir=1){
    const pts = [];
    let x = x0, y = y0;
    for(let i=0;i<steps;i++){
      const k1 = orthSlope(x,y);
      if(k1===null) break;
      const k2s = orthSlope(x + 0.5*h*dir, y + 0.5*h*dir*k1);
      if(k2s===null) break;
      const k3s = orthSlope(x + 0.5*h*dir, y + 0.5*h*dir*k2s);
      if(k3s===null) break;
      const k4s = orthSlope(x + h*dir, y + h*dir*k3s);
      if(k4s===null) break;
      const dy = (h*dir)*(k1 + 2*k2s + 2*k3s + k4s)/6;
      y = y + dy;
      x = x + h*dir;
      if(!isFinite(x) || !isFinite(y) || Math.abs(y) > 1e6) break;
      pts.push([x,y]);
    }
    return pts;
  }

  // Build datasets for plotly
  const Rng = parseFloat(document.getElementById('range')?.value||5);
  const ntra = parseInt(document.getElementById('ntra')?.value||8);
  const gridN = 120;
  const xMin = -Rng, xMax = Rng, yMin = -Rng, yMax = Rng;

  // create contour grid for original family (F(x,y))
  const xs = []; for(let i=0;i<gridN;i++) xs.push(xMin + (xMax-xMin)*i/(gridN-1));
  const ys = []; for(let j=0;j<gridN;j++) ys.push(yMin + (yMax-yMin)*j/(gridN-1));
  const z = new Array(gridN).fill(0).map(()=>new Array(gridN).fill(0));
  for(let i=0;i<gridN;i++){
    for(let j=0;j<gridN;j++){
      try{ z[j][i] = F.evaluate({x: xs[i], y: ys[j]}); }catch(e){ z[j][i] = NaN }
    }
  }

  // Choose C levels automatically around mean
  // Evaluate at center for reference
  const sampleCs = [];
  // compute some sample Cs by sampling random points where F is finite
  const samples = [];
  for(let i=0;i<10;i++){const xi = xMin + Math.random()*(xMax-xMin); const yi = yMin + Math.random()*(yMax-yMin); try{const v = F.evaluate({x:xi,y:yi}); if(isFinite(v)) samples.push(v);}catch(e){}
  }
  if(samples.length===0) samples.push(0);
  samples.sort((a,b)=>a-b);
  const mid = samples[Math.floor(samples.length/2)];
  const span = Math.max(1, Math.abs(samples[samples.length-1]-samples[0]) || 1);
  for(let k=-3;k<=3;k++) sampleCs.push(mid + k*(span/6));

  const contour = {
    x: xs, y: ys, z: z,
    type: 'contour', colorscale:'YlGnBu', contours:{start:sampleCs[0],end:sampleCs[sampleCs.length-1],size:(sampleCs[1]-sampleCs[0])||1,showlabels:false},
    showscale:false, name: 'Family level sets'
  };

  // Create orthogonal trajectories by integrating from different seeds along x=const grid
  const trajs = [];
  // pick seeds: choose several x positions and for each choose a few y seeds
  const seedXs = [];
  for(let i=0;i<ntra;i++) seedXs.push(xMin + (xMax-xMin)*(i+0.5)/ntra);
  for(const sx of seedXs){
    // pick y starting points by solving F(x,s_y)=C for several Cs — but easier: take evenly spaced y's
    const seedYs = [];
    for(let k=0;k<3;k++) seedYs.push(yMin + (yMax-yMin)*(k+0.2));
    for(const sy of seedYs){
      // integrate forward and backward
      const forward = integrateRK4(sx,sy, (xMax-xMin)/400, 200, +1);
      const backward = integrateRK4(sx,sy, (xMax-xMin)/400, 200, -1);
      const pts = backward.reverse().concat([[sx,sy]], forward);
      if(pts.length>3){
        trajs.push({x: pts.map(p=>p[0]), y: pts.map(p=>p[1])});
      }
    }
  }

  // Also draw a few explicit level-set curves for F(x,y)=C by contour already done above. But we can overlay contour lines at sampleCs
  const contourLevels = {
    x: xs, y: ys, z: z, type: 'contour', showscale:false,
    contours: {values: sampleCs}, line:{width:2}, colorscale:'Greys', name:'Level sets'
  };

  // Plot
  const data = [contour, contourLevels];
  // add each trajectory as line
  trajs.forEach(t=>{data.push({x:t.x,y:t.y,mode:'lines',name:'Orthogonal traj',line:{width:2}})});

  const layout = {margin:{t:30,l:30,r:30,b:30},height:420,legend:{orientation:'h'},xaxis:{range:[xMin,xMax]},yaxis:{range:[yMin,yMax],scaleanchor:'x'}};
  Plotly.newPlot(plotArea, data, layout, {responsive:true});

}catch(err){
  stepsArea.innerHTML = `<div style="color:#ff9b9b">Error while processing: ${esc(err.message||err+'')}</div>`;
  console.error(err);
}

}

  </script>
</body>
</html> 

